从输入URL到页面显示都经历了什么
1. 构建请求
2. 查找强缓存
3. DNS解析
我们输入的是域名，而数据包是通过IP地址传给对方的。因为我们需要得到域名对应的IP地址。这个过程需要依赖一个服务系统，这个过程将域名和IP一一映射，这个系统就叫DNS系统。
需要注意的是DNS有多级缓存，如果有缓存，下次就不需要走解析，直接走缓存
4. 建立TCP连接
chrome的同一个域名最多只能有6个TCP连接，超过就得等待
主要有三个阶段：
  1. 建立连接，经过三次握手
  2. 进行数据传输：这里有一个重要机制就是数据重传。接收方收到数据包后必须要发送包确认，如果发送方没有收到这个确认消息，就认为数据包丢失，则重新发送数据包。还有一个优化策略，就是将大的数据包拆成小包，
  3. 断开连接的时候，需要四次挥手来断开连接
5. 发送HTTP请求


1，用户输入url并回车
2，浏览器进程检查url，组装协议，构成完整的url
3，浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
4，网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
5，如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：
    5.1 进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）
    5.2 利用ip地址和服务器建立tcp连接
    5.3 构建请求头信息
    5.4 发送请求头信息
    5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
6，网络进程解析响应流程；
    6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步
        （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。
    6.2 200响应处理：
        检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行
        后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。
7，准备渲染进程
    7.1 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
8. 传输数据、更新状态
    8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
    8.2 渲染进程接收完数据后，向浏览器发送“确认提交”
    8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。
渲染部分:
  1. 渲染进程把HTML内容转换为能够读懂的DOM树结构
  2. 渲染殷勤将css样式表转换为浏览器可以理解的styleSheets，计算出DOM节点的样式
  3. 创建布局树，并计算元素的布局信息
  4. 对布局树进行分层，并生成分层树
  5. 为每个图层生成绘制列表，并将其提交到合成线程
  6. 合成线程把图层分成图块，并在光栅化线程池中把图块转换为位图
  7. 合成线程发送绘制图块命令drawQuad给浏览器线程
  8. 浏览器进程根据drawQuad消息生成页面，并显示到显示器上

缓存问题
https://juejin.im/post/5c22ee806fb9a049fb43b2c5?utm_source=gold_browser_extension#heading-6
memory cache
几乎所有的网络请求资源都会被浏览器自动加入到memory cache，但是因为数量很大但是浏览器占用的缓存不能无限扩大，所以只能是个短期存储。常规情况下，浏览器的TAB关闭后该次memory cache就会失效。极端情况，即使该tab没有失效，但是超出了容量前面的缓存也会失效。
几乎所有的请求资源主要包含两大类
1. preloader资源 主要包括script，额外的css，img图片
2. preload 预加载资源
保证了一个页面如果有个两个相同的请求，实际最多会被请求一次。
但是在匹配缓存的时候，除了匹配完全相同的URL外，还会对他们的类型，CORS中的域名规则等。
memory cache会忽略cache-control中的配置，如果两个图片的src都相同，但是依然会从缓存中读取。如果要禁止memory cache可以设置cache-control 为no-store
disk cache
也叫http cache。是存储在硬盘上的缓存。他允许相同的资源跨对话甚至跨站点，例如两个站点都使用了同一张图片。
disk cache会严格根据HTTP头信息中的各类字段来判断哪些资源可以缓存，哪些资源不可以缓存；哪些资源是仍然可用的，哪些资源是过时需要重新请求的。
service worker
上面提到的缓存策略都是浏览器内部去判断或者进行的，我们只能设置响应字段来告诉浏览器，而不能自己操作。service worker给与了一种更加灵活、更加直接的操作方式。能够让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持久性的。
service worker实现缓存功能一般分为三个步骤：首先需要注册service worker，然后监听到install事件以后就可以缓存需要的文件，那么下次用户访问的时候通过拦截请求的方式查询是否有缓存，存在缓存的话就可以读取缓存文件。
如果service worker没有命中缓存，一般情况下会使用fetch()方法继续获取资源。这时候，浏览器就去memory cache或者disk cache进行下一次找缓存的内容
强制缓存:
当客户端请求后，会先访问缓存数据库看缓存是否存在。如果存在就直接返回；不存在就请求服务区，响应后在写入缓存数据库。强缓存直接减少请求数，是提升最大的缓存策略
可以造成强制缓存的字段为:cache-control和expires
expires： 表示过期时间
  两个缺点: 1. 客户端和服务端时间不一致；2. 写法复杂
cache-control: 表示资源缓存的最大有效时间，和expires的区别在于，前面是绝对时间，这个是相对时间
下面是常用字段:
max-age: 即最大有效时间
no-cache: 要求客户端缓存内容，但是是否使用这个内容由后续的对比来决定
no-store: 真正意义上的不要缓存
public: 内容客户端和代理服务器可以缓存
private: 内容只有客户端可以缓存
协商缓存
浏览器先请求缓存数据库，返回一个缓存标识。之后浏览器拿这个标识和服务器通讯。如果缓存未失效，则返回HTTP状态码304表示继续使用，于是客户端继续使用缓存
协商缓存在请求数上和没有缓存是一致的，主要是少了响应结果
主要有两组字段
last-Modified If-Modified-Since
缺陷： 
1. 如果资源更新的速度是秒以下单位的，那么缓存是不能被使用的，因为他的时间单位最低是秒
2. 如果文件是通过服务器生成的， 那么更新时间永远都是生成时间，尽管文件可能没有变化，所以起不到缓存的作用
Etag & If-None-Match
Etag存储的是文件的特殊标识，

网络问题
事件循环：
1. 所有同步任务在主线程上执行，形成一个执行栈
2. 当主线程的执行栈为空，检查任务队列中是否为空，如果为空，即继续查找，如果不为空，则执行3
3. 取出任务队列的首部，压入执行栈
4. 执行任务
5. 检查执行栈，如果执行栈为空，则调回第2部，如不为空，则继续检查

1. 从宏队列中的头部取出一个任务执行;
2. 从执行过程中若遇到微任务将其添加到微任务的队列中
3. 宏任务执行完毕后，微任务的队列中是否存在任务，若存在，则挨个执行，直到执行完毕
4. GUI渲染
5. 重复执行上面操作
macrotask:
  script、setTimeout、I/O、UI、postMessage
microtask:
  promise.then、MutationObserver

js 垃圾回收
标记清除：从根部触发是否能达到某个对象，如果能达到则认定这个对象还被需要，如果无法达到，则释放他：
1. 垃圾回收期创建roots列表，roots通常是代码中保留引用的全局变量，在js中，我们一般认为全局对象window作为root
2. 从根部触发检查所有的roots，所有的children都会被递归检查，能从root到达的都被标记为active
3. 未被标记为active的数据被认为不在需要，垃圾回收器开始释放他们